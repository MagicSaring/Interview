一、#用来把参数转换成字符串

例子一：

#define P(A) printf("%s:%d\n",#A,A);

int main(int argc, char **argv)

{
        int a = 1, b = 2;

        P(a);

        P(b);

        P(a+b);

        system("pause");

}

输出为:
a:1
b:2
a + b:3

例子二：

#define SQUARE(x) printf("The square of "#x" is %d.\n", ((x)*(x)));

SQUARE(8)
输出的是：The square of 8 is 64

二、##运算符可以用于宏函数的替换部分。这个运算符把两个语言符号组合成单个语言符号，为宏扩展提供了一种连接实际变元的手段

例子一：

#define XNAME(n) x ## n

如果这样使用宏：XNAME(8)

则会被展开成这样：x8

##就是个粘合剂，将前后两部分粘合起来，也就是有“字符化”的意思。但是“##”不能随意粘合任意字符，必须是合法的C语言标示符。
在单一的宏定义中，最多可以出现一次“#”或“##”预处理操作符。
如果没有指定与“#”或“##”预处理操作符相关的计算次序，则会产生问题。
为避免该问题，在单一的宏定义中只能使用其中一种操作符(即，一份“#”或一个“##”，或都不用)。
除非非常有必要，否则尽量不要使用“#”和“##”。

三、__VA_ARGS__ 是一个可变参数的宏，很少人知道这个宏，这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支持（VC6.0的编译器不支持）。
实现思想就是宏定义中参数列表的最后一个参数为省略号（也就是三个点）。

四、##__VA_ARGS__ 宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的","去掉的作用,否则会编译出错

一般这个用在调试信息上多一点

例如：

 #define my_print1(...)  printf(__VA_ARGS__)   my_print1("i=%d,j=%d\n",i,j)  正确打印

#define my_print2(fmt,...)  printf(fmt,__VA_ARGS__)  

my_print1("i=%d,j=%d\n",i,j) 正确打印

my_print2("iiiiiii\n")       编译失败打印，因为扩展出来只有一个参数，至少要两个及以上参数

如果是#define my_print2(fmt,...)  printf(fmt,##__VA_ARGS__)  

#define MODULE_NAME "MY_LIBS"
 
#define error_printf(fmt,...) printf("[ERROR]["MODULE_NAME"](%s|%d)"fmt,__func__,__LINE__,##__VA_ARGS__)
那么

my_print1里面不管是几个参数都能正确打印